# Squishmallowdex v1.2.0 Solution Design

## Overview

**Feature:** Self-upgrade functionality
**Goal:** Allow users to upgrade Squishmallowdex to the latest release with a single command, preserving their collection data.

```bash
python3 squishmallowdex.py --upgrade
```

---

## User Stories

1. As a collector, I want to upgrade to the latest version without losing my favourites or ownership data.
2. As a kid, I want upgrading to be as simple as running one command.
3. As a cautious user, I want my data backed up before any upgrade happens.
4. As a user, I want to check if updates are available without installing them.
5. As a user, I want to see what changed before I upgrade.

---

## Phase 1: Version Infrastructure

### 1.1 Embed Version in Script

Add version constant at the top of the script:

```python
__version__ = "1.2.0"
__version_info__ = (1, 2, 0)
```

**Location:** After imports, before constants.

### 1.2 Version Comparison

```python
def parse_version(version_str: str) -> tuple[int, ...]:
    """Parse version string like '1.2.3' into tuple (1, 2, 3)."""
    # Strip leading 'v' if present
    version_str = version_str.lstrip('v')
    return tuple(int(x) for x in version_str.split('.'))

def is_newer_version(current: str, candidate: str) -> bool:
    """Return True if candidate is newer than current."""
    return parse_version(candidate) > parse_version(current)
```

### 1.3 --version Flag

```python
parser.add_argument(
    '--version',
    action='version',
    version=f'%(prog)s {__version__}'
)
```

---

## Phase 2: Update Check

### 2.1 GitHub Releases API

**Endpoint:** `https://api.github.com/repos/adrianwedd/squishmallowdex/releases/latest`

**Response (relevant fields):**
```json
{
  "tag_name": "v1.2.1",
  "name": "v1.2.1 - Bug fixes",
  "body": "## What's Changed\n- Fixed thumbnail caching...",
  "published_at": "2026-01-10T12:00:00Z",
  "assets": [
    {
      "name": "squishmallowdex.py",
      "browser_download_url": "https://github.com/.../squishmallowdex.py"
    }
  ]
}
```

### 2.2 Check Function

```python
GITHUB_REPO = "adrianwedd/squishmallowdex"
RELEASES_API = f"https://api.github.com/repos/{GITHUB_REPO}/releases/latest"

def check_for_updates(session: requests.Session) -> dict | None:
    """
    Check GitHub for newer releases.

    Returns:
        dict with keys: version, name, body, download_url, published_at
        None if no update available or check failed
    """
    try:
        resp = session.get(RELEASES_API, timeout=10)
        resp.raise_for_status()
        release = resp.json()

        latest_version = release["tag_name"].lstrip("v")

        if not is_newer_version(__version__, latest_version):
            return None

        # Find the script asset
        download_url = None
        for asset in release.get("assets", []):
            if asset["name"] == "squishmallowdex.py":
                download_url = asset["browser_download_url"]
                break

        # Fallback to raw file from tag if no release asset
        if not download_url:
            download_url = f"https://raw.githubusercontent.com/{GITHUB_REPO}/{release['tag_name']}/squishmallowdex.py"

        return {
            "version": latest_version,
            "name": release.get("name", f"v{latest_version}"),
            "body": release.get("body", ""),
            "download_url": download_url,
            "published_at": release.get("published_at", ""),
        }
    except Exception as e:
        logging.warning(f"Update check failed: {e}")
        return None
```

### 2.3 --check-update Flag

```python
parser.add_argument(
    '--check-update',
    action='store_true',
    help='Check if a newer version is available'
)
```

**Output (no update):**
```
  Squishmallowdex v1.2.0
  You're up to date!
```

**Output (update available):**
```
  Squishmallowdex v1.2.0

  Update available: v1.2.1
  Published: January 10, 2026

  What's new:
  - Fixed thumbnail caching bug
  - Added new squad filter

  Run with --upgrade to install
```

---

## Phase 3: Backup System

### 3.1 Backup Directory Structure

```
backups/
  2026-01-05_v1.2.0/
    squishmallowdex.py          # Current script
    squishmallowdex.html        # User's collection
    squishmallowdex.csv
    squishmallowdex.json        # If exists
    squish_images/              # Thumbnail cache
    squishmallow.log
    manifest.json               # Backup metadata
```

### 3.2 Backup Manifest

```json
{
  "backup_version": 1,
  "created_at": "2026-01-05T10:30:00Z",
  "from_version": "1.2.0",
  "to_version": "1.2.1",
  "files": [
    {"path": "squishmallowdex.py", "size": 85000, "sha256": "abc123..."},
    {"path": "squishmallowdex.html", "size": 2500000, "sha256": "def456..."},
    ...
  ]
}
```

### 3.3 Backup Function

```python
BACKUP_DIR = "backups"
BACKUP_FILES = [
    "squishmallowdex.py",
    "squishmallowdex.html",
    "squishmallowdex.csv",
    "squishmallowdex.json",
    "squishmallow.log",
]
BACKUP_DIRS = [
    "squish_images",
]

def create_backup(target_version: str) -> str:
    """
    Create a backup of current state before upgrade.

    Returns:
        Path to backup directory

    Raises:
        RuntimeError if backup fails
    """
    timestamp = datetime.now().strftime("%Y-%m-%d_%H%M%S")
    backup_name = f"{timestamp}_v{__version__}"
    backup_path = os.path.join(BACKUP_DIR, backup_name)

    os.makedirs(backup_path, exist_ok=True)

    manifest = {
        "backup_version": 1,
        "created_at": datetime.now().isoformat(),
        "from_version": __version__,
        "to_version": target_version,
        "files": [],
    }

    # Copy files
    for filename in BACKUP_FILES:
        if os.path.exists(filename):
            dest = os.path.join(backup_path, filename)
            shutil.copy2(filename, dest)
            manifest["files"].append({
                "path": filename,
                "size": os.path.getsize(dest),
                "sha256": file_sha256(dest),
            })

    # Copy directories
    for dirname in BACKUP_DIRS:
        if os.path.isdir(dirname):
            dest = os.path.join(backup_path, dirname)
            shutil.copytree(dirname, dest)
            manifest["files"].append({
                "path": dirname,
                "type": "directory",
            })

    # Write manifest
    manifest_path = os.path.join(backup_path, "manifest.json")
    with open(manifest_path, "w") as f:
        json.dump(manifest, f, indent=2)

    return backup_path
```

### 3.4 Restore Function

```python
def restore_backup(backup_path: str) -> None:
    """
    Restore from a backup directory.

    Used if upgrade fails and rollback is needed.
    """
    manifest_path = os.path.join(backup_path, "manifest.json")
    with open(manifest_path) as f:
        manifest = json.load(f)

    for file_info in manifest["files"]:
        src = os.path.join(backup_path, file_info["path"])
        if file_info.get("type") == "directory":
            if os.path.exists(file_info["path"]):
                shutil.rmtree(file_info["path"])
            shutil.copytree(src, file_info["path"])
        else:
            shutil.copy2(src, file_info["path"])

    print(f"  Restored from backup: {backup_path}")
```

---

## Phase 4: Download and Install

### 4.1 Download New Version

```python
def download_new_version(url: str, session: requests.Session) -> bytes:
    """
    Download the new script from GitHub.

    Returns:
        Script content as bytes

    Raises:
        RuntimeError if download fails
    """
    resp = session.get(url, timeout=60)
    resp.raise_for_status()

    content = resp.content

    # Basic validation
    if b"def main(" not in content:
        raise RuntimeError("Downloaded file doesn't look like squishmallowdex.py")

    if b"__version__" not in content:
        raise RuntimeError("Downloaded file missing version info")

    return content
```

### 4.2 Install New Version

```python
def install_new_version(content: bytes) -> None:
    """
    Replace current script with new version.

    The script replaces itself, so this is the point of no return
    (hence why backup happens first).
    """
    script_path = os.path.abspath(__file__)

    # Write to temp file first
    temp_path = script_path + ".new"
    with open(temp_path, "wb") as f:
        f.write(content)

    # Make executable (preserve original permissions)
    original_mode = os.stat(script_path).st_mode
    os.chmod(temp_path, original_mode)

    # Atomic replace
    os.replace(temp_path, script_path)
```

### 4.3 Verify Installation

```python
def verify_installation() -> bool:
    """
    Verify the new script works by running --version.

    Returns:
        True if verification passed
    """
    try:
        result = subprocess.run(
            [sys.executable, __file__, "--version"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        return result.returncode == 0
    except Exception:
        return False
```

---

## Phase 5: Migration System

### 5.1 Migration Registry

Migrations run when upgrading across versions that changed data formats.

```python
MIGRATIONS = {
    # "from_version": migration_function
    # Example: "1.2.0": migrate_1_2_0_to_1_2_1,
}

def get_pending_migrations(from_version: str, to_version: str) -> list:
    """
    Get list of migrations needed between versions.

    Migrations are run in version order.
    """
    pending = []
    from_tuple = parse_version(from_version)
    to_tuple = parse_version(to_version)

    for version_str, migration_fn in sorted(MIGRATIONS.items(), key=lambda x: parse_version(x[0])):
        v = parse_version(version_str)
        if from_tuple <= v < to_tuple:
            pending.append((version_str, migration_fn))

    return pending
```

### 5.2 Migration Function Template

```python
def migrate_example(backup_path: str) -> None:
    """
    Example migration from v1.2.0 to v1.2.1.

    Args:
        backup_path: Path to backup (for reference, not modification)

    Migrations should:
    - Modify files in place (current directory)
    - Be idempotent (safe to run twice)
    - Log what they do
    """
    # Example: Add new column to CSV
    csv_path = "squishmallowdex.csv"
    if os.path.exists(csv_path):
        # Read, transform, write
        logging.info("Migration: Added 'New Column' to CSV")
```

### 5.3 Run Migrations

```python
def run_migrations(from_version: str, to_version: str, backup_path: str) -> None:
    """Run all pending migrations."""
    pending = get_pending_migrations(from_version, to_version)

    if not pending:
        return

    print(f"  Running {len(pending)} migration(s)...")

    for version_str, migration_fn in pending:
        print(f"    Migrating from v{version_str}...")
        migration_fn(backup_path)

    print("  Migrations complete!")
```

---

## Phase 6: Main Upgrade Flow

### 6.1 --upgrade Flag

```python
parser.add_argument(
    '--upgrade',
    action='store_true',
    help='Upgrade to the latest version'
)
```

### 6.2 Upgrade Function

```python
def do_upgrade(session: requests.Session, force: bool = False) -> int:
    """
    Main upgrade flow.

    Returns:
        0 on success, 1 on failure
    """
    print()
    print("  SQUISHMALLOWDEX UPGRADE")
    print("  " + "=" * 40)
    print()
    print(f"  Current version: v{__version__}")
    print()

    # Step 1: Check for updates
    print("  Checking for updates...")
    update = check_for_updates(session)

    if not update:
        print("  You're already on the latest version!")
        return 0

    # Step 2: Show what's new
    print(f"  New version available: v{update['version']}")
    print()
    if update['body']:
        print("  What's new:")
        for line in update['body'].split('\n')[:10]:  # First 10 lines
            print(f"    {line}")
        print()

    # Step 3: Confirm (unless --force)
    if not force:
        print("  This will:")
        print("    1. Back up your collection and settings")
        print("    2. Download the new version")
        print("    3. Run any needed migrations")
        print()
        confirm = input("  Proceed with upgrade? [y/N] ").strip().lower()
        if confirm not in ('y', 'yes'):
            print("  Upgrade cancelled.")
            return 0

    print()

    # Step 4: Backup
    print("  Creating backup...")
    try:
        backup_path = create_backup(update['version'])
        print(f"  Backup saved to: {backup_path}")
    except Exception as e:
        print(f"  Backup failed: {e}")
        print("  Upgrade aborted. No changes were made.")
        return 1

    # Step 5: Download
    print()
    print("  Downloading new version...")
    try:
        new_script = download_new_version(update['download_url'], session)
        print(f"  Downloaded {len(new_script):,} bytes")
    except Exception as e:
        print(f"  Download failed: {e}")
        print("  Upgrade aborted. No changes were made.")
        return 1

    # Step 6: Install
    print()
    print("  Installing...")
    try:
        install_new_version(new_script)
        print("  Script updated!")
    except Exception as e:
        print(f"  Installation failed: {e}")
        print("  Attempting rollback...")
        restore_backup(backup_path)
        return 1

    # Step 7: Verify
    print()
    print("  Verifying installation...")
    if not verify_installation():
        print("  Verification failed!")
        print("  Rolling back...")
        restore_backup(backup_path)
        return 1
    print("  Verification passed!")

    # Step 8: Run migrations
    print()
    run_migrations(__version__, update['version'], backup_path)

    # Step 9: Success!
    print()
    print("  " + "=" * 40)
    print(f"  UPGRADE COMPLETE! Now running v{update['version']}")
    print()
    print(f"  Your backup is at: {backup_path}")
    print("  (You can delete it once you're happy)")
    print()

    return 0
```

---

## Phase 7: Additional Flags

### 7.1 --force Flag

Skip confirmation prompt:

```python
parser.add_argument(
    '--force',
    action='store_true',
    help='Skip confirmation prompts'
)
```

### 7.2 --list-backups Flag

```python
parser.add_argument(
    '--list-backups',
    action='store_true',
    help='List available backups'
)

def list_backups() -> None:
    """Show available backups."""
    if not os.path.isdir(BACKUP_DIR):
        print("  No backups found.")
        return

    backups = sorted(os.listdir(BACKUP_DIR), reverse=True)
    if not backups:
        print("  No backups found.")
        return

    print("  Available backups:")
    print()
    for backup in backups:
        manifest_path = os.path.join(BACKUP_DIR, backup, "manifest.json")
        if os.path.exists(manifest_path):
            with open(manifest_path) as f:
                m = json.load(f)
            print(f"    {backup}")
            print(f"      From: v{m['from_version']} -> v{m['to_version']}")
            print(f"      Created: {m['created_at']}")
            print()
```

### 7.3 --restore Flag

```python
parser.add_argument(
    '--restore',
    metavar='BACKUP',
    help='Restore from a backup (use --list-backups to see options)'
)
```

---

## Phase 8: Error Handling & Edge Cases

### 8.1 No Internet

```
  Checking for updates...
  Could not reach GitHub. Check your internet connection.
```

### 8.2 Rate Limited

GitHub API has rate limits (60/hour unauthenticated). Handle gracefully:

```
  Checking for updates...
  GitHub rate limit reached. Try again in a few minutes.
```

### 8.3 Disk Full

Check disk space before backup:

```python
def check_disk_space(required_mb: int = 100) -> bool:
    """Ensure enough disk space for backup."""
    stat = os.statvfs('.')
    free_mb = (stat.f_frsize * stat.f_bavail) / (1024 * 1024)
    return free_mb >= required_mb
```

### 8.4 Permission Denied

```
  Installation failed: Permission denied
  Try running with sudo, or check file permissions.
```

### 8.5 Upgrade While Running

The script replaces itself, so the running instance continues with old code. This is fine - the new version takes effect on next run.

---

## Testing Plan

### Unit Tests

1. `test_parse_version` - Version string parsing
2. `test_is_newer_version` - Version comparison
3. `test_create_backup` - Backup creation with manifest
4. `test_restore_backup` - Backup restoration
5. `test_migrations` - Migration ordering and execution

### Integration Tests (Manual)

1. Fresh install â†’ upgrade to newer version
2. Upgrade with existing collection data
3. Rollback after failed installation
4. Restore from backup
5. Multiple sequential upgrades

### Mock Tests

Use `responses` to mock GitHub API:

```python
@responses.activate
def test_check_for_updates_available():
    responses.add(
        responses.GET,
        RELEASES_API,
        json={
            "tag_name": "v99.0.0",
            "name": "v99.0.0",
            "body": "Test release",
            "assets": [],
        }
    )
    update = check_for_updates(requests.Session())
    assert update is not None
    assert update["version"] == "99.0.0"
```

---

## UI/Output Design

### Check Update Output

```
    SQUISHMALLOWDEX v1.2.0

    Checking for updates...

    Update available: v1.2.1
    Released: January 10, 2026

    What's new:
    - Fixed thumbnail caching bug
    - Added new squad filter
    - Performance improvements

    Run with --upgrade to install
```

### Upgrade Progress Output

```
    SQUISHMALLOWDEX UPGRADE
    ========================================

    Current version: v1.2.0

    Checking for updates...
    New version available: v1.2.1

    What's new:
    - Fixed thumbnail caching bug
    - Added new squad filter

    This will:
      1. Back up your collection and settings
      2. Download the new version
      3. Run any needed migrations

    Proceed with upgrade? [y/N] y

    Creating backup...
    Backup saved to: backups/2026-01-05_103000_v1.2.0

    Downloading new version...
    Downloaded 87,432 bytes

    Installing...
    Script updated!

    Verifying installation...
    Verification passed!

    ========================================
    UPGRADE COMPLETE! Now running v1.2.1

    Your backup is at: backups/2026-01-05_103000_v1.2.0
    (You can delete it once you're happy)
```

---

## Implementation Phases

| Phase | Description | Estimate |
|-------|-------------|----------|
| 1 | Version infrastructure | Small |
| 2 | Update check (--check-update) | Small |
| 3 | Backup system | Medium |
| 4 | Download and install | Medium |
| 5 | Migration system | Small |
| 6 | Main upgrade flow | Medium |
| 7 | Additional flags | Small |
| 8 | Error handling | Small |
| 9 | Testing | Medium |

---

## Security Considerations

1. **HTTPS only** - All downloads over HTTPS
2. **Verify content** - Check downloaded file looks like valid Python
3. **No arbitrary code** - Only download from official repo
4. **Backup first** - Always backup before replacing

---

## Future Enhancements (Out of Scope)

- **Downgrade support** - Roll back to specific version
- **Auto-update check** - Check on every run (with opt-out)
- **Update notifications** - Desktop notification when update available
- **Changelog viewer** - Browse all release notes
- **Beta channel** - Opt-in to pre-release versions
