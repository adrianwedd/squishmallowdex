# v1.3 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add color filtering, URL-based saved views, and i18n UI (English + Spanish) to the Squishmallowdex collection browser.

**Architecture:** Single-file vanilla JS app (`docs/squishmallowdex.html`). Color filtering integrates with the existing filter pipeline. URL hash encoding stores shareable state (search + colors + sort). i18n refactors all hardcoded UI strings into a centralized object with language switching.

**Tech Stack:** Vanilla JS, CSS, HTML. No dependencies. URLSearchParams for hash encoding. localStorage for language preference and personal state.

---

# Feature 1 — Color Filtering

## Task 1: Parse and extract unique colors

**Files:**
- Modify: `docs/squishmallowdex.html` (init section, lines 700-800)

**Step 1: Add color parser function**

In the IIFE, after the `LS_KEYS` constant and before `buildColumnPicker()`, add:

```js
function parseColors() {
  const canonicalColors = ["Pink", "Blue", "Green", "Orange", "Yellow", "Purple", "Red", "Grey", "White", "Black", "Tan", "Turquoise", "Lavender", "Rainbow", "Tie-dye", "Silver", "Cream"];
  const colorMap = new Map(canonicalColors.map(c => [c.toLowerCase(), c]));
  const foundColors = new Set();
  const hasUnknown = false;

  rowModels.forEach(model => {
    if (!model.color) return;
    const colors = model.color.split(',').map(c => c.trim().toLowerCase());
    colors.forEach(c => {
      if (colorMap.has(c)) {
        foundColors.add(colorMap.get(c));
      } else if (c) {
        hasUnknown = true;
      }
    });
  });

  const sorted = Array.from(foundColors).sort();
  if (hasUnknown) sorted.push('Other');
  return sorted;
}

const availableColors = parseColors();
let selectedColors = new Set();
```

**Step 2: Build color chip UI**

After `buildSortHeaderUI()`, add:

```js
function buildColorFilter() {
  const filterContainer = document.createElement('div');
  filterContainer.className = 'color-filter';

  const label = document.createElement('label');
  label.textContent = 'Color:';
  filterContainer.appendChild(label);

  const chipsContainer = document.createElement('div');
  chipsContainer.className = 'color-chips';

  availableColors.forEach(color => {
    const chip = document.createElement('button');
    chip.type = 'button';
    chip.className = 'color-chip';
    chip.textContent = color;
    chip.dataset.color = color;

    // Style the chip background
    const bgColor = getColorBackground(color);
    if (bgColor) chip.style.backgroundColor = bgColor;
    chip.style.opacity = '0.6';

    chip.addEventListener('click', () => {
      if (selectedColors.has(color)) {
        selectedColors.delete(color);
        chip.style.opacity = '0.6';
      } else {
        selectedColors.add(color);
        chip.style.opacity = '1.0';
      }
      applyFiltersAndSort();
    });

    chipsContainer.appendChild(chip);
  });

  filterContainer.appendChild(chipsContainer);
  return filterContainer;
}

function getColorBackground(colorName) {
  const colorMap = {
    'Pink': '#FFB6C1', 'Blue': '#87CEEB', 'Green': '#90EE90', 'Orange': '#FFA500',
    'Yellow': '#FFFF99', 'Purple': '#DDA0DD', 'Red': '#FF6B6B', 'Grey': '#C0C0C0',
    'White': '#F5F5F5', 'Black': '#404040', 'Tan': '#D2B48C', 'Turquoise': '#40E0D0',
    'Lavender': '#E6D9FF', 'Rainbow': '#FFD700', 'Tie-dye': '#A0A0FF', 'Silver': '#C0C0C0',
    'Cream': '#FFFDD0', 'Other': '#D3D3D3'
  };
  return colorMap[colorName];
}

// Call after search input, before filters
const colorFilterUI = buildColorFilter();
searchContainer.after(colorFilterUI);
```

**Step 3: Integrate color filter into computeVisibleIds()**

Find `computeVisibleIds()` (around line 1200). Add color matching:

```js
function computeVisibleIds() {
  const q = search.value.trim().toLowerCase();
  const ids = new Set();
  rowModels.forEach((model) => {
    const matchesSearch = !q || model.searchText.includes(q);
    const matchesFav = !showOnlyFav || !!favourites[model.id];
    const matchesOwn = !showOnlyOwn || !!owned[model.id];

    // Color filter: match ALL selected colors (AND logic)
    let matchesColor = selectedColors.size === 0; // if no colors selected, match all
    if (!matchesColor && selectedColors.size > 0) {
      const itemColors = model.color.split(',').map(c => c.trim());
      matchesColor = Array.from(selectedColors).every(selected => {
        if (selected === 'Other') {
          // Match if item has unknown colors
          return itemColors.some(c => !isKnownColor(c));
        }
        return itemColors.includes(selected);
      });
    }

    if (matchesSearch && matchesFav && matchesOwn && matchesColor) ids.add(model.id);
  });
  return ids;
}

function isKnownColor(c) {
  const canonicalColors = ["Pink", "Blue", "Green", "Orange", "Yellow", "Purple", "Red", "Grey", "White", "Black", "Tan", "Turquoise", "Lavender", "Rainbow", "Tie-dye", "Silver", "Cream"];
  return canonicalColors.map(x => x.toLowerCase()).includes(c.toLowerCase());
}
```

**Step 4: Add CSS for color chips**

In `<style>`, add:

```css
.color-filter {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 0 15px;
  flex-wrap: wrap;
}

.color-filter label {
  font-weight: bold;
  white-space: nowrap;
}

.color-chips {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.color-chip {
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-radius: 20px;
  cursor: pointer;
  transition: opacity 0.2s;
  font-size: 0.9rem;
  color: #333;
}

.color-chip:hover {
  opacity: 0.8 !important;
}
```

**Step 5: Commit**

```bash
cd /Users/adrian/repos/squishmallowdex
git add docs/squishmallowdex.html
git commit -m "feat(color-filter): add color-based multi-select filtering

Extracts unique canonical colors from dataset. Adds color chip UI
with AND semantics (only items matching all selected colors shown).
Integrates with existing filter pipeline. Handles unknown colors
as 'Other' chip.

Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>"
```

---

## Task 2: QA Color Filtering

**Manual QA checklist:**

1. Page loads, color chips visible in toolbar
2. Click a single color chip (e.g. Pink) → results filter, chip highlights (opacity 1.0)
3. Click another chip (e.g. Blue) → AND logic, results show only items with BOTH pink AND blue
4. Click a chip with "Other" → shows items with unknown colors
5. Combine with search (e.g. search "cat" + color Pink) → only pink cats shown
6. Combine with favorites-only → only favorited pink items
7. Toggle between table and card views → color filter remains active, results consistent
8. Reload page → color selection is cleared (not persisted yet; that's Feature 2)

**Report back:** Any regressions in existing filters? All color combinations working?

---

# Feature 2 — URL-Based Saved Views

## Task 3: Add URL state encoding/decoding

**Files:**
- Modify: `docs/squishmallowdex.html` (init and filter sections)

**Step 1: Add URL state helpers**

After `parseColors()`, add:

```js
function encodeHashState() {
  const params = new URLSearchParams();
  if (search.value.trim()) params.set('search', search.value.trim());
  if (selectedColors.size > 0) params.set('colors', Array.from(selectedColors).join(','));
  if (sortState.field) {
    params.set('sortField', sortState.field);
    params.set('sortDir', sortState.dir === 1 ? 'asc' : 'desc');
  }
  const hash = params.toString();
  window.location.hash = hash ? '#' + hash : '';
}

function decodeHashState() {
  const hash = window.location.hash.slice(1); // remove #
  const params = new URLSearchParams(hash);
  const state = {
    search: params.get('search') || '',
    colors: params.get('colors') ? params.get('colors').split(',') : [],
    sortField: params.get('sortField') || 'table',
    sortDir: params.get('sortDir') === 'desc' ? -1 : 1
  };
  return state;
}

function applyHashState(state) {
  if (state.search) search.value = state.search;
  state.colors.forEach(c => selectedColors.add(c));
  if (state.sortField !== 'table') {
    sortState.field = state.sortField;
    sortState.dir = state.sortDir;
  }
}

let isApplyingHashState = false;
```

**Step 2: Parse hash on page load**

In the init block (before `applyViewMode`), add:

```js
// Apply hash state if present, else use localStorage
const hashState = decodeHashState();
if (window.location.hash) {
  isApplyingHashState = true;
  applyHashState(hashState);
  isApplyingHashState = false;
}

// Then apply other init logic
applyViewMode(viewMode);
```

**Step 3: Update hash on filter changes**

In `bindGlobalControls()`, after each filter listener, call `encodeHashState()`:

```js
search.addEventListener('input', () => {
  clearTimeout(searchDebounceTimer);
  searchDebounceTimer = setTimeout(() => {
    encodeHashState();
    applyFiltersAndSort();
  }, 130);
});

filterFav.addEventListener('click', () => {
  showOnlyFav = !showOnlyFav;
  filterFav.classList.toggle('active', showOnlyFav);
  encodeHashState();
  applyFiltersAndSort();
});

filterOwn.addEventListener('click', () => {
  showOnlyOwn = !showOnlyOwn;
  filterOwn.classList.toggle('active', showOnlyOwn);
  encodeHashState();
  applyFiltersAndSort();
});

// In sort header click:
th.addEventListener('click', () => {
  // ... existing sort logic ...
  encodeHashState();
  applyFiltersAndSort();
});

// In card sort change:
cardSort.addEventListener('change', () => {
  applyCardSortSelection(cardSort.value);
  persistCardSortSelection();
  encodeHashState();
  applyFiltersAndSort();
});
```

**Step 4: Add hashchange listener**

After `bindGlobalControls()`, add:

```js
window.addEventListener('hashchange', () => {
  if (isApplyingHashState) return; // guard against loops
  isApplyingHashState = true;
  const state = decodeHashState();
  search.value = state.search || '';
  selectedColors.clear();
  state.colors.forEach(c => selectedColors.add(c));
  if (state.sortField !== 'table') {
    applyCardSortSelection(`${state.sortField}:${state.sortDir === 1 ? 'asc' : 'desc'}`);
    syncCardSortControl();
  } else {
    applyCardSortSelection('table');
    syncCardSortControl();
  }
  isApplyingHashState = false;
  applyFiltersAndSort();
});
```

**Step 5: Add "Share" button**

In the toolbar HTML (after the color filter), add:

```html
<button type="button" id="shareBtn" title="Copy shareable link">Share</button>
```

Add listener in `bindGlobalControls()`:

```js
document.getElementById('shareBtn').addEventListener('click', () => {
  const url = window.location.href;
  navigator.clipboard.writeText(url).then(() => {
    alert('Link copied to clipboard! Share it with others to show this filtered view.');
  });
});
```

**Step 6: Commit**

```bash
git add docs/squishmallowdex.html
git commit -m "feat(saved-views): URL-based shareable filter state

Encodes search, colors, and sort into URL hash using URLSearchParams.
On page load, parses hash state and applies filters. Updates hash
on every filter/sort change. Handles browser back/forward via
hashchange listener with state guard to prevent loops. Adds Share
button to copy link. Excludes favOnly/ownOnly (personal data).

Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>"
```

---

## Task 4: QA URL Saved Views

**Manual QA checklist:**

1. Set filters (search "cat", select Pink color, sort by Year) → URL hash is updated to `#search=cat&colors=Pink&sortField=year&sortDir=asc`
2. Copy URL, open in new tab → state is restored (same filters apply)
3. Open in incognito/private mode → filters work, but favorites/owned items are empty (as expected)
4. Click Share button → URL copied to clipboard
5. Use browser back button after changing filters → previous state is restored via hashchange
6. Forward button → newer state restored
7. Manually edit URL hash (e.g. change color) → reload restores edited state
8. Select favOnly/ownOnly → verify they do NOT appear in URL hash

**Report back:** URL state working as intended? Any stale state issues?

---

# Feature 3 — i18n UI + Spanish

## Task 5: Build i18n object and extract English strings

**Files:**
- Modify: `docs/squishmallowdex.html` (style + init + all UI sections)

**Step 1: Create i18n object (English base)**

After `LS_KEYS`, add:

```js
const i18n = {
  en: {
    buttons: {
      table: 'Table',
      cards: 'Cards',
      compact: 'Compact',
      columns: 'Columns',
      share: 'Share',
      favorite: 'Favourite',
      own: 'Own',
      wiki: 'wiki',
      buy: 'Buy on Amazon',
    },
    filters: {
      search: 'Search',
      favOnly: 'Favorites only',
      ownOnly: 'I own it',
      color: 'Color',
    },
    status: {
      loading: 'Loading cards…',
      viewMode: 'View mode',
      columnPicker: 'Columns',
      formatCount: (n, total) => n === total ? `${total} Squishmallows` : `Showing ${n} of ${total}`,
    },
    colors: {
      pink: 'Pink',
      blue: 'Blue',
      green: 'Green',
      orange: 'Orange',
      yellow: 'Yellow',
      purple: 'Purple',
      red: 'Red',
      grey: 'Grey',
      white: 'White',
      black: 'Black',
      tan: 'Tan',
      turquoise: 'Turquoise',
      lavender: 'Lavender',
      rainbow: 'Rainbow',
      'tie-dye': 'Tie-dye',
      silver: 'Silver',
      cream: 'Cream',
      other: 'Other',
    },
    disclosure: 'Affiliate Disclosure: As an Amazon Associate, we earn from qualifying purchases. When you buy through our links, we may earn a small commission at no extra cost to you. This helps support this free educational project. Thank you! ❤️',
  },
  es: {
    buttons: {
      table: 'Tabla',
      cards: 'Tarjetas',
      compact: 'Compacto',
      columns: 'Columnas',
      share: 'Compartir',
      favorite: 'Favorito',
      own: 'Tengo',
      wiki: 'wiki',
      buy: 'Comprar en Amazon',
    },
    filters: {
      search: 'Buscar',
      favOnly: 'Solo favoritos',
      ownOnly: 'Tengo éste',
      color: 'Color',
    },
    status: {
      loading: 'Cargando tarjetas…',
      viewMode: 'Modo de vista',
      columnPicker: 'Columnas',
      formatCount: (n, total) => n === total ? `${total} Squishmallows` : `Mostrando ${n} de ${total}`,
    },
    colors: {
      pink: 'Rosa',
      blue: 'Azul',
      green: 'Verde',
      orange: 'Naranja',
      yellow: 'Amarillo',
      purple: 'Púrpura',
      red: 'Rojo',
      grey: 'Gris',
      white: 'Blanco',
      black: 'Negro',
      tan: 'Canela',
      turquoise: 'Turquesa',
      lavender: 'Lavanda',
      rainbow: 'Arcoíris',
      'tie-dye': 'Teñido',
      silver: 'Plateado',
      cream: 'Crema',
      other: 'Otro',
    },
    disclosure: 'Divulgación de Afiliados: Como Asociado de Amazon, ganamos con compras calificadas. Cuando compras a través de nuestros enlaces, podemos ganar una pequeña comisión sin costo adicional. Esto ayuda a mantener este proyecto educativo gratuito. ¡Gracias! ❤️',
  }
};

let currentLang = localStorage.getItem('squishdex-lang') || 'en';
document.documentElement.lang = currentLang;

function t(key, ...args) {
  const path = key.split('.');
  let obj = i18n[currentLang];
  for (const p of path) obj = obj[p];
  return typeof obj === 'function' ? obj(...args) : obj;
}
```

**Step 2: Replace hardcoded button/label text in HTML**

Find all hardcoded strings in the HTML `<button>`, `<label>`, and placeholder attributes. For example:

- `<button>Table</button>` → `<button id="viewTableBtn" data-i18n="buttons.table">Table</button>`
- `<input placeholder="Search...">` → `<input id="search" placeholder="Search" data-i18n-placeholder="filters.search">`

Add init code to populate these:

```js
function populateI18n() {
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.dataset.i18n;
    el.textContent = t(key);
  });
  document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
    const key = el.dataset.i18nPlaceholder;
    el.placeholder = t(key);
  });
  document.querySelectorAll('[data-i18n-title]').forEach(el => {
    const key = el.dataset.i18nTitle;
    el.title = t(key);
  });
}

populateI18n();
```

**Step 3: Replace aria-labels with localized versions**

In JavaScript code that creates buttons (e.g., `buildCardView()`), use `t()`:

```js
heart.setAttribute('aria-label', `${t('buttons.favorite')} ${model.name || 'Squishmallow'}`);
ownCb.setAttribute('aria-label', `${t('buttons.own')} ${model.name || 'this squishmallow'}`);
wiki.setAttribute('aria-label', `${t('buttons.wiki')} page for ${model.name || 'Squishmallow'}`);
buy.setAttribute('aria-label', `${t('buttons.buy')} ${model.name || 'Squishmallow'}`);
```

**Step 4: Replace count/status text**

In `updateCount()`:

```js
function updateCount(visible, total) {
  countEl.textContent = t('status.formatCount', visible, total);
}
```

**Step 5: Add language switcher**

In the toolbar HTML (after Share button), add:

```html
<select id="langSwitcher" data-i18n-title="status.viewMode">
  <option value="en">English</option>
  <option value="es">Español</option>
</select>
```

Add listener in `bindGlobalControls()`:

```js
document.getElementById('langSwitcher').addEventListener('change', (e) => {
  currentLang = e.target.value;
  localStorage.setItem('squishdex-lang', currentLang);
  document.documentElement.lang = currentLang;
  populateI18n();
  // Re-render dynamic aria-labels and status
  document.querySelectorAll('.heart-btn').forEach(btn => {
    const id = btn.dataset.id;
    syncSelectionState(id);
  });
  updateCount(document.querySelectorAll('tr:not([style*="display: none"])').length, rowModels.length);
});
```

**Step 6: Commit**

```bash
git add docs/squishmallowdex.html
git commit -m "feat(i18n): centralized UI string localization with English base

Created i18n object with en and es translations for buttons, labels,
status text, colors, and footer disclosure. Added t() lookup function.
Marked HTML elements with data-i18n attributes for runtime string
replacement. Stored language preference in localStorage. Added language
switcher in toolbar. All UI chrome now localized; dataset content
(names, bios, types, colors) remains in English.

Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>"
```

---

## Task 6: Add Spanish translations to i18n object (if not done in Task 5)

Verify all strings in the i18n object are translated to Spanish. Focus on ensuring pluralization and context are correct.

---

## Task 7: QA i18n + Spanish

**Manual QA checklist:**

1. Page loads in English (default)
2. Click language switcher → select Spanish → all UI text changes to Spanish
3. Reload page → language persists (still Spanish)
4. Switch back to English → all text reverts
5. Check pluralization: "1 Squishmallow" (singular) vs "5 Squishmallows" (plural) in both languages
6. Test aria-labels: add a favorite → aria-label reads "Favorito" or "Favourite" depending on language
7. Toggle card/table view in Spanish → view toggle buttons show Spanish text
8. Use filters in Spanish → button and label text localized
9. Copy link in Spanish mode → hash values remain canonical (English colors, field names)
10. Open shared link in English mode → filters apply correctly (canonicality verified)
11. Color chip names reflect current language (e.g., "Rosa" in Spanish, "Pink" in English)

**Report back:** All strings localized? No stale English text visible? Pluralization working?

---

## Task 8: Final QA — All Features Together

**Integration checklist:**

1. **Color + Views + i18n:** Set color filter + search in Spanish mode → URL hash has canonical values → copy link → open in English → same filters apply
2. **No regressions:** All existing features (favorites, owned, sort, card/table toggle, compact mode) still work
3. **Accessibility:** aria-labels in active language; focus styles present; keyboard nav works
4. **Mobile:** Color chips responsive on narrow screens; language switcher accessible

**Report back:** Ready to ship v1.3.0?

---

## Completion

### Commit sequence
1. Color filtering (Task 1-2)
2. URL saved views (Task 3-4)
3. i18n + Spanish (Task 5-8)

### Final release
```bash
gh release create v1.3.0 --title "v1.3.0 — Color Filter, Saved Views, i18n" --notes "..."
```

### Close related issues
```bash
gh issue close 9  # Color-based filtering
gh issue close 5  # i18n framework
gh issue close 8  # Spanish translation
```
